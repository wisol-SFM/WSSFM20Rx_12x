<html lang="en">
<head>
<title>Miscellaneous - Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="BFD-front-end.html#BFD-front-end" title="BFD front end">
<link rel="prev" href="Error-reporting.html#Error-reporting" title="Error reporting">
<link rel="next" href="Memory-Usage.html#Memory-Usage" title="Memory Usage">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents the BFD library.

Copyright (C) 1991-2015 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Miscellaneous"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Memory-Usage.html#Memory-Usage">Memory Usage</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Error-reporting.html#Error-reporting">Error reporting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="BFD-front-end.html#BFD-front-end">BFD front end</a>
<hr>
</div>

<h3 class="section">2.3 Miscellaneous</h3>

<h4 class="subsection">2.3.1 Miscellaneous functions</h4>

<p><a name="index-bfd_005fget_005freloc_005fupper_005fbound-14"></a>

<h5 class="subsubsection">2.3.1.1 <code>bfd_get_reloc_upper_bound</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
</pre>
   <p><strong>Description</strong><br>
Return the number of bytes required to store the
relocation information associated with section <var>sect</var>
attached to bfd <var>abfd</var>.  If an error occurs, return -1.

   <p><a name="index-bfd_005fcanonicalize_005freloc-15"></a>

<h5 class="subsubsection">2.3.1.2 <code>bfd_canonicalize_reloc</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     long bfd_canonicalize_reloc
        (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
</pre>
   <p><strong>Description</strong><br>
Call the back end associated with the open BFD
<var>abfd</var> and translate the external form of the relocation
information attached to <var>sec</var> into the internal canonical
form.  Place the table into memory at <var>loc</var>, which has
been preallocated, usually by a call to
<code>bfd_get_reloc_upper_bound</code>.  Returns the number of relocs, or
-1 on error.

   <p>The <var>syms</var> table is also needed for horrible internal magic
reasons.

   <p><a name="index-bfd_005fset_005freloc-16"></a>

<h5 class="subsubsection">2.3.1.3 <code>bfd_set_reloc</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     void bfd_set_reloc
        (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
</pre>
   <p><strong>Description</strong><br>
Set the relocation pointer and count within
section <var>sec</var> to the values <var>rel</var> and <var>count</var>. 
The argument <var>abfd</var> is ignored.

   <p><a name="index-bfd_005fset_005ffile_005fflags-17"></a>

<h5 class="subsubsection">2.3.1.4 <code>bfd_set_file_flags</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
</pre>
   <p><strong>Description</strong><br>
Set the flag word in the BFD <var>abfd</var> to the value <var>flags</var>.

   <p>Possible errors are:
     <ul>
<li><code>bfd_error_wrong_format</code> - The target bfd was not of object format. 
<li><code>bfd_error_invalid_operation</code> - The target bfd was open for reading. 
<li><code>bfd_error_invalid_operation</code> -
The flag word contained a bit which was not applicable to the
type of file.  E.g., an attempt was made to set the <code>D_PAGED</code> bit
on a BFD format which does not support demand paging. 
</ul>

   <p><a name="index-bfd_005fget_005farch_005fsize-18"></a>

<h5 class="subsubsection">2.3.1.5 <code>bfd_get_arch_size</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     int bfd_get_arch_size (bfd *abfd);
</pre>
   <p><strong>Description</strong><br>
Returns the normalized architecture address size, in bits, as
determined by the object file's format.  By normalized, we mean
either 32 or 64.  For ELF, this information is included in the
header.  Use bfd_arch_bits_per_address for number of bits in
the architecture address.

   <p><strong>Returns</strong><br>
Returns the arch size in bits if known, <code>-1</code> otherwise.

   <p><a name="index-bfd_005fget_005fsign_005fextend_005fvma-19"></a>

<h5 class="subsubsection">2.3.1.6 <code>bfd_get_sign_extend_vma</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     int bfd_get_sign_extend_vma (bfd *abfd);
</pre>
   <p><strong>Description</strong><br>
Indicates if the target architecture "naturally" sign extends
an address.  Some architectures implicitly sign extend address
values when they are converted to types larger than the size
of an address.  For instance, bfd_get_start_address() will
return an address sign extended to fill a bfd_vma when this is
the case.

   <p><strong>Returns</strong><br>
Returns <code>1</code> if the target architecture is known to sign
extend addresses, <code>0</code> if the target architecture is known to
not sign extend addresses, and <code>-1</code> otherwise.

   <p><a name="index-bfd_005fset_005fstart_005faddress-20"></a>

<h5 class="subsubsection">2.3.1.7 <code>bfd_set_start_address</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
</pre>
   <p><strong>Description</strong><br>
Make <var>vma</var> the entry point of output BFD <var>abfd</var>.

   <p><strong>Returns</strong><br>
Returns <code>TRUE</code> on success, <code>FALSE</code> otherwise.

   <p><a name="index-bfd_005fget_005fgp_005fsize-21"></a>

<h5 class="subsubsection">2.3.1.8 <code>bfd_get_gp_size</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     unsigned int bfd_get_gp_size (bfd *abfd);
</pre>
   <p><strong>Description</strong><br>
Return the maximum size of objects to be optimized using the GP
register under MIPS ECOFF.  This is typically set by the <code>-G</code>
argument to the compiler, assembler or linker.

   <p><a name="index-bfd_005fset_005fgp_005fsize-22"></a>

<h5 class="subsubsection">2.3.1.9 <code>bfd_set_gp_size</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     void bfd_set_gp_size (bfd *abfd, unsigned int i);
</pre>
   <p><strong>Description</strong><br>
Set the maximum size of objects to be optimized using the GP
register under ECOFF or MIPS ELF.  This is typically set by
the <code>-G</code> argument to the compiler, assembler or linker.

   <p><a name="index-bfd_005fscan_005fvma-23"></a>

<h5 class="subsubsection">2.3.1.10 <code>bfd_scan_vma</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
</pre>
   <p><strong>Description</strong><br>
Convert, like <code>strtoul</code>, a numerical expression
<var>string</var> into a <code>bfd_vma</code> integer, and return that integer. 
(Though without as many bells and whistles as <code>strtoul</code>.) 
The expression is assumed to be unsigned (i.e., positive). 
If given a <var>base</var>, it is used as the base for conversion. 
A base of 0 causes the function to interpret the string
in hex if a leading "0x" or "0X" is found, otherwise
in octal if a leading zero is found, otherwise in decimal.

   <p>If the value would overflow, the maximum <code>bfd_vma</code> value is
returned.

   <p><a name="index-bfd_005fcopy_005fprivate_005fheader_005fdata-24"></a>

<h5 class="subsubsection">2.3.1.11 <code>bfd_copy_private_header_data</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
</pre>
   <p><strong>Description</strong><br>
Copy private BFD header information from the BFD <var>ibfd</var> to the
the BFD <var>obfd</var>.  This copies information that may require
sections to exist, but does not require symbol tables.  Return
<code>true</code> on success, <code>false</code> on error. 
Possible error returns are:

     <ul>
<li><code>bfd_error_no_memory</code> -
Not enough memory exists to create private data for <var>obfd</var>. 
</ul>

<pre class="example">     #define bfd_copy_private_header_data(ibfd, obfd) \
          BFD_SEND (obfd, _bfd_copy_private_header_data, \
                    (ibfd, obfd))
</pre>
   <p><a name="index-bfd_005fcopy_005fprivate_005fbfd_005fdata-25"></a>

<h5 class="subsubsection">2.3.1.12 <code>bfd_copy_private_bfd_data</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
</pre>
   <p><strong>Description</strong><br>
Copy private BFD information from the BFD <var>ibfd</var> to the
the BFD <var>obfd</var>.  Return <code>TRUE</code> on success, <code>FALSE</code> on error. 
Possible error returns are:

     <ul>
<li><code>bfd_error_no_memory</code> -
Not enough memory exists to create private data for <var>obfd</var>. 
</ul>

<pre class="example">     #define bfd_copy_private_bfd_data(ibfd, obfd) \
          BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
                    (ibfd, obfd))
</pre>
   <p><a name="index-bfd_005fmerge_005fprivate_005fbfd_005fdata-26"></a>

<h5 class="subsubsection">2.3.1.13 <code>bfd_merge_private_bfd_data</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
</pre>
   <p><strong>Description</strong><br>
Merge private BFD information from the BFD <var>ibfd</var> to the
the output file BFD <var>obfd</var> when linking.  Return <code>TRUE</code>
on success, <code>FALSE</code> on error.  Possible error returns are:

     <ul>
<li><code>bfd_error_no_memory</code> -
Not enough memory exists to create private data for <var>obfd</var>. 
</ul>

<pre class="example">     #define bfd_merge_private_bfd_data(ibfd, obfd) \
          BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
                    (ibfd, obfd))
</pre>
   <p><a name="index-bfd_005fset_005fprivate_005fflags-27"></a>

<h5 class="subsubsection">2.3.1.14 <code>bfd_set_private_flags</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
</pre>
   <p><strong>Description</strong><br>
Set private BFD flag information in the BFD <var>abfd</var>. 
Return <code>TRUE</code> on success, <code>FALSE</code> on error.  Possible error
returns are:

     <ul>
<li><code>bfd_error_no_memory</code> -
Not enough memory exists to create private data for <var>obfd</var>. 
</ul>

<pre class="example">     #define bfd_set_private_flags(abfd, flags) \
          BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
</pre>
   <p><a name="index-Other-functions-28"></a>

<h5 class="subsubsection">2.3.1.15 <code>Other functions</code></h5>

<p><strong>Description</strong><br>
The following functions exist but have not yet been documented.
<pre class="example">     #define bfd_sizeof_headers(abfd, info) \
            BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, info))
     
     #define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
            BFD_SEND (abfd, _bfd_find_nearest_line, \
                      (abfd, syms, sec, off, file, func, line, NULL))
     
     #define bfd_find_nearest_line_discriminator(abfd, sec, syms, off, file, func, \
                                                 line, disc) \
            BFD_SEND (abfd, _bfd_find_nearest_line, \
                      (abfd, syms, sec, off, file, func, line, disc))
     
     #define bfd_find_line(abfd, syms, sym, file, line) \
            BFD_SEND (abfd, _bfd_find_line, \
                      (abfd, syms, sym, file, line))
     
     #define bfd_find_inliner_info(abfd, file, func, line) \
            BFD_SEND (abfd, _bfd_find_inliner_info, \
                      (abfd, file, func, line))
     
     #define bfd_debug_info_start(abfd) \
            BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
     
     #define bfd_debug_info_end(abfd) \
            BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
     
     #define bfd_debug_info_accumulate(abfd, section) \
            BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
     
     #define bfd_stat_arch_elt(abfd, stat) \
            BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
     
     #define bfd_update_armap_timestamp(abfd) \
            BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
     
     #define bfd_set_arch_mach(abfd, arch, mach)\
            BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
     
     #define bfd_relax_section(abfd, section, link_info, again) \
            BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
     
     #define bfd_gc_sections(abfd, link_info) \
            BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
     
     #define bfd_lookup_section_flags(link_info, flag_info, section) \
            BFD_SEND (abfd, _bfd_lookup_section_flags, (link_info, flag_info, section))
     
     #define bfd_merge_sections(abfd, link_info) \
            BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
     
     #define bfd_is_group_section(abfd, sec) \
            BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))
     
     #define bfd_discard_group(abfd, sec) \
            BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
     
     #define bfd_link_hash_table_create(abfd) \
            BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
     
     #define bfd_link_add_symbols(abfd, info) \
            BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
     
     #define bfd_link_just_syms(abfd, sec, info) \
            BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
     
     #define bfd_final_link(abfd, info) \
            BFD_SEND (abfd, _bfd_final_link, (abfd, info))
     
     #define bfd_free_cached_info(abfd) \
            BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
     
     #define bfd_get_dynamic_symtab_upper_bound(abfd) \
            BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
     
     #define bfd_print_private_bfd_data(abfd, file)\
            BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
     
     #define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
            BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
     
     #define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
            BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
                                                        dyncount, dynsyms, ret))
     
     #define bfd_get_dynamic_reloc_upper_bound(abfd) \
            BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
     
     #define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
            BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
     
     extern bfd_byte *bfd_get_relocated_section_contents
       (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
        bfd_boolean, asymbol **);
     
</pre>
   <p><a name="index-bfd_005falt_005fmach_005fcode-29"></a>

<h5 class="subsubsection">2.3.1.16 <code>bfd_alt_mach_code</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
</pre>
   <p><strong>Description</strong><br>
When more than one machine code number is available for the
same machine type, this function can be used to switch between
the preferred one (alternative == 0) and any others.  Currently,
only ELF supports this feature, with up to two alternate
machine codes.

   <p><a name="index-bfd_005femul_005fget_005fmaxpagesize-30"></a>

<h5 class="subsubsection">2.3.1.17 <code>bfd_emul_get_maxpagesize</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_vma bfd_emul_get_maxpagesize (const char *);
</pre>
   <p><strong>Description</strong><br>
Returns the maximum page size, in bytes, as determined by
emulation.

   <p><strong>Returns</strong><br>
Returns the maximum page size in bytes for ELF, 0 otherwise.

   <p><a name="index-bfd_005femul_005fset_005fmaxpagesize-31"></a>

<h5 class="subsubsection">2.3.1.18 <code>bfd_emul_set_maxpagesize</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     void bfd_emul_set_maxpagesize (const char *, bfd_vma);
</pre>
   <p><strong>Description</strong><br>
For ELF, set the maximum page size for the emulation.  It is
a no-op for other formats.

   <p><a name="index-bfd_005femul_005fget_005fcommonpagesize-32"></a>

<h5 class="subsubsection">2.3.1.19 <code>bfd_emul_get_commonpagesize</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_vma bfd_emul_get_commonpagesize (const char *);
</pre>
   <p><strong>Description</strong><br>
Returns the common page size, in bytes, as determined by
emulation.

   <p><strong>Returns</strong><br>
Returns the common page size in bytes for ELF, 0 otherwise.

   <p><a name="index-bfd_005femul_005fset_005fcommonpagesize-33"></a>

<h5 class="subsubsection">2.3.1.20 <code>bfd_emul_set_commonpagesize</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     void bfd_emul_set_commonpagesize (const char *, bfd_vma);
</pre>
   <p><strong>Description</strong><br>
For ELF, set the common page size for the emulation.  It is
a no-op for other formats.

   <p><a name="index-bfd_005fdemangle-34"></a>

<h5 class="subsubsection">2.3.1.21 <code>bfd_demangle</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     char *bfd_demangle (bfd *, const char *, int);
</pre>
   <p><strong>Description</strong><br>
Wrapper around cplus_demangle.  Strips leading underscores and
other such chars that would otherwise confuse the demangler. 
If passed a g++ v3 ABI mangled name, returns a buffer allocated
with malloc holding the demangled name.  Returns NULL otherwise
and on memory alloc failure.

   <p><a name="index-bfd_005fupdate_005fcompression_005fheader-35"></a>

<h5 class="subsubsection">2.3.1.22 <code>bfd_update_compression_header</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     void bfd_update_compression_header
        (bfd *abfd, bfd_byte *contents, asection *sec);
</pre>
   <p><strong>Description</strong><br>
Set the compression header at CONTENTS of SEC in ABFD and update
elf_section_flags for compression.

   <p><a name="index-bfd_005fcheck_005fcompression_005fheader-36"></a>

<h5 class="subsubsection">2.3.1.23 <code>bfd_check_compression_header</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     bfd_boolean bfd_check_compression_header
        (bfd *abfd, bfd_byte *contents, asection *sec,
         bfd_size_type *uncompressed_size);
</pre>
   <p><strong>Description</strong><br>
Check the compression header at CONTENTS of SEC in ABFD and
store the uncompressed size in UNCOMPRESSED_SIZE if the
compression header is valid.

   <p><strong>Returns</strong><br>
Return TRUE if the compression header is valid.

   <p><a name="index-bfd_005fget_005fcompression_005fheader_005fsize-37"></a>

<h5 class="subsubsection">2.3.1.24 <code>bfd_get_compression_header_size</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     int bfd_get_compression_header_size (bfd *abfd, asection *sec);
</pre>
   <p><strong>Description</strong><br>
Return the size of the compression header of SEC in ABFD.

   <p><strong>Returns</strong><br>
Return the size of the compression header in bytes.

   <p><a name="index-struct-bfd_005fiovec-38"></a>

<h5 class="subsubsection">2.3.1.25 <code>struct bfd_iovec</code></h5>

<p><strong>Description</strong><br>
The <code>struct bfd_iovec</code> contains the internal file I/O class. 
Each <code>BFD</code> has an instance of this class and all file I/O is
routed through it (it is assumed that the instance implements
all methods listed below).
<pre class="example">     struct bfd_iovec
     {
       /* To avoid problems with macros, a "b" rather than "f"
          prefix is prepended to each method name.  */
       /* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching
          bytes starting at PTR.  Return the number of bytes actually
          transfered (a read past end-of-file returns less than NBYTES),
          or -1 (setting <code>bfd_error</code>) if an error occurs.  */
       file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
       file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
                           file_ptr nbytes);
       /* Return the current IOSTREAM file offset, or -1 (setting <code>bfd_error</code>
          if an error occurs.  */
       file_ptr (*btell) (struct bfd *abfd);
       /* For the following, on successful completion a value of 0 is returned.
          Otherwise, a value of -1 is returned (and  <code>bfd_error</code> is set).  */
       int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
       int (*bclose) (struct bfd *abfd);
       int (*bflush) (struct bfd *abfd);
       int (*bstat) (struct bfd *abfd, struct stat *sb);
       /* Mmap a part of the files. ADDR, LEN, PROT, FLAGS and OFFSET are the usual
          mmap parameter, except that LEN and OFFSET do not need to be page
          aligned.  Returns (void *)-1 on failure, mmapped address on success.
          Also write in MAP_ADDR the address of the page aligned buffer and in
          MAP_LEN the size mapped (a page multiple).  Use unmap with MAP_ADDR and
          MAP_LEN to unmap.  */
       void *(*bmmap) (struct bfd *abfd, void *addr, bfd_size_type len,
                       int prot, int flags, file_ptr offset,
                       void **map_addr, bfd_size_type *map_len);
     };
     extern const struct bfd_iovec _bfd_memory_iovec;
</pre>
   <p><a name="index-bfd_005fget_005fmtime-39"></a>

<h5 class="subsubsection">2.3.1.26 <code>bfd_get_mtime</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     long bfd_get_mtime (bfd *abfd);
</pre>
   <p><strong>Description</strong><br>
Return the file modification time (as read from the file system, or
from the archive header for archive members).

   <p><a name="index-bfd_005fget_005fsize-40"></a>

<h5 class="subsubsection">2.3.1.27 <code>bfd_get_size</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     file_ptr bfd_get_size (bfd *abfd);
</pre>
   <p><strong>Description</strong><br>
Return the file size (as read from file system) for the file
associated with BFD <var>abfd</var>.

   <p>The initial motivation for, and use of, this routine is not
so we can get the exact size of the object the BFD applies to, since
that might not be generally possible (archive members for example). 
It would be ideal if someone could eventually modify
it so that such results were guaranteed.

   <p>Instead, we want to ask questions like "is this NNN byte sized
object I'm about to try read from file offset YYY reasonable?" 
As as example of where we might do this, some object formats
use string tables for which the first <code>sizeof (long)</code> bytes of the
table contain the size of the table itself, including the size bytes. 
If an application tries to read what it thinks is one of these
string tables, without some way to validate the size, and for
some reason the size is wrong (byte swapping error, wrong location
for the string table, etc.), the only clue is likely to be a read
error when it tries to read the table, or a "virtual memory
exhausted" error when it tries to allocate 15 bazillon bytes
of space for the 15 bazillon byte table it is about to read. 
This function at least allows us to answer the question, "is the
size reasonable?".

   <p><a name="index-bfd_005fmmap-41"></a>

<h5 class="subsubsection">2.3.1.28 <code>bfd_mmap</code></h5>

<p><strong>Synopsis</strong>
<pre class="example">     void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
         int prot, int flags, file_ptr offset,
         void **map_addr, bfd_size_type *map_len);
</pre>
   <p><strong>Description</strong><br>
Return mmap()ed region of the file, if possible and implemented. 
LEN and OFFSET do not need to be page aligned.  The page aligned
address and length are written to MAP_ADDR and MAP_LEN.

   </body></html>

